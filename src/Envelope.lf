target uC

preamble {=
  #include "psynth.h"

  typedef enum {
    MODE_IDLE,
    MODE_ATTACK,
    MODE_DECAY,
    MODE_SUSTAIN,
    MODE_RELEASE
  } envelope_mode_t;
=}

reactor AmplitudeEnvelope {
  input note_on: bool
  input note_off: bool
  input samples_raw: sample_buffer_t
  output samples: sample_buffer_t
}

// An amplitude envelope with 4 parameters. Uses modal reactors to
// jump between the 4 states.
reactor ADSREnvelope(
    attack: time = 50 msec,
    decay: time = 50 msec,
    sustain: SAMPLE_TYPE = 0.8,
    release: time = 40 msec) extends AmplitudeEnvelope {
  input ctrl: midi_controller_change_t
  input velocity_in: int
  output dead: bool

  state attack_rate: double
  state decay_rate: double
  state release_rate: double
  state velocity: double

  state attack_start: instant_t
  state decay_start: instant_t
  state release_start: instant_t
  state sustain_start: instant_t
  state amp_start: double = 0
  state env_mode: envelope_mode_t = {=MODE_IDLE=}

  reaction(ctrl) {=
    switch (ctrl->value.controller) {
      case AMP_ENVELOPE: {
        if (ctrl->value.value == 0) ctrl->value.value++;
        self->release = SEC(1) * ctrl->value.value/127;
        self->release_rate = self->sustain/self->release;
        self->attack = SEC(1) * ctrl->value.value/127;
        self->attack_rate = 1.0/self->attack;
        break;
      }
    }
  =}

  reaction(startup) -> samples {=
    self->attack_rate = 1.0/self->attack;
    self->decay_rate= (1.0 - self->sustain)/self->decay;
    self->release_rate = self->sustain/self->release;
  =}

  reaction(note_on) velocity_in {=
    switch (self->env_mode) {
      case MODE_IDLE:
        // lf_print("Attack");
        self->attack_start = env->get_elapsed_logical_time(env);
        self->decay_start = self->attack_start + self->attack;
        self->sustain_start = self->decay_start + self->decay;
        self->amp_start = 0;
        self->velocity = ((double)velocity_in->value)/127.0;
        self->env_mode = MODE_ATTACK;
        break;
      case MODE_ATTACK:
      case MODE_DECAY:
      case MODE_SUSTAIN:
      case MODE_RELEASE:
      default:
        validate(false);
    }
    =}

    reaction(samples_raw) -> samples, dead {=
      switch (self->env_mode) {
      case MODE_ATTACK: {
        instant_t now = env->get_elapsed_logical_time(env);
        instant_t ts = now - self->attack_start;

        SAMPLE_TYPE amp;
        sample_buffer_t _samples;
        for (int i = 0; i<SAMPLE_SIZE; i++) {
          amp = (ts + SEC(i*SAMPLE_STEP)) * self->attack_rate;
          _samples.buffer[i] = samples_raw->value.buffer[i] * amp * self->velocity;
        }
        self->amp_start = amp;
        lf_set(samples, _samples);

        if (now >= self->decay_start) {
          self->env_mode = MODE_DECAY;
        }
        break;
      }
      case MODE_DECAY: {
        instant_t now = env->get_elapsed_logical_time(env);
        instant_t ts  = now - self->decay_start;
        SAMPLE_TYPE amp;

        sample_buffer_t _samples;
        for (int i = 0; i<SAMPLE_SIZE; i++) {
          amp = self->amp_start - (ts + SEC(i*SAMPLE_STEP)) * self->decay_rate;
          _samples.buffer[i] = samples_raw->value.buffer[i] * amp * self->velocity;
        }
        lf_set(samples, _samples);
        self->amp_start = amp;

        if (now >= self->sustain_start || amp <= self->sustain) {
          self->env_mode = MODE_SUSTAIN;
        }
        break;
      }
      case MODE_SUSTAIN:
        sample_buffer_t _samples;
        for (int i = 0; i<SAMPLE_SIZE; i++) {
          _samples.buffer[i] = samples_raw->value.buffer[i] * self->amp_start * self->velocity;
        }
        lf_set(samples, _samples);
        break;
      case MODE_RELEASE: {
        instant_t now = env->get_elapsed_logical_time(env);
        instant_t ts = now - self->release_start;
        sample_buffer_t _samples;
        bool done = false;
          for (int i = 0; i<SAMPLE_SIZE; i++) {
            SAMPLE_TYPE amp = self->amp_start - (ts + SEC(i*SAMPLE_STEP)) * self->release_rate;
            if (amp <= 0) {
              amp = 0;
              done = true;
            }
            _samples.buffer[i] = samples_raw->value.buffer[i] * amp * self->velocity;
          }
        if(done) {
          lf_set(dead, true);
          self->env_mode = MODE_IDLE;
        }
        lf_set(samples, _samples);
        break;
      }
      case MODE_IDLE:
      default:
        break;
    }
    =}

    reaction(note_off) {=
      switch(self->env_mode) {
        case MODE_ATTACK:
          self->env_mode = MODE_RELEASE;
          self->release_start = env->get_elapsed_logical_time(env);
          break;
        case MODE_DECAY:
          self->env_mode = MODE_RELEASE;
          self->release_start = env->get_elapsed_logical_time(env);
          break;
        case MODE_SUSTAIN:
          self->env_mode = MODE_RELEASE;
          self->release_start = env->get_elapsed_logical_time(env);
          break;
        case MODE_IDLE:
          validate(false);
          break;
      }
    =}
}
