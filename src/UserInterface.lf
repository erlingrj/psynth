target uC

import KeyboardInput from "lib/Keyboard.lf"

preamble {=
  #include "psynth.h"
=}

reactor UserInterface {
  preamble {=
    #include <stdio.h>
  =}
  input samples: sample_buffer_t*
  output midi_event: midi_base_msg_t
}

reactor FileInterface extends UserInterface {
  preamble {=
    #include <stdio.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include "midi.h"
    #define _GNU_SOURCE
    #include <pthread.h>
    #include <sched.h>

    bool stop = false;

    static void midi_reader_loop(int fd, void *action, midi_parser_t *parser) {
        char recv;
        // Get the maximum priority for the given scheduling policy
        // int maxPriority = sched_get_priority_max(SCHED_FIFO);

        // // Set the scheduling policy and priority for the current thread
        // struct sched_param param;
        // param.sched_priority = maxPriority;

        // if (pthread_setschedparam(pthread_self(), SCHED_FIFO, &param) != 0) {
        //     perror("pthread_setschedparam");
        //     // Handle the error
        //     return -1;
        // }
        while (!stop) {
            // Read a MIDI message (3 bytes)
            ssize_t bytes_read = read(fd, &recv, 1);
            // Check for errors or end-of-file
            if (bytes_read < 0) {
                printf("Error reading from MIDI device\n");
                return;
            } else if (bytes_read == 0) {
                printf("Error reading from MIDI device\n");
                return;
            }
            // printf("%02x \n", (unsigned char) recv);
            if (midi_parser(parser, recv)) {
                // printf("FOUND MIDI MSG\n");
                lf_schedule_copy(action, 0, &parser->msg, 1);
                memset(&parser->msg, 0, sizeof(parser->msg));
            }
        }
        close(fd);
    }

    void* midi_reader_worker(void *action) {
        midi_parser_t *parser = create_midi_parser();
        if (!parser) {
            validate(false);
        }
        while (!stop) {
            // Open the MIDI device file
            // FIXME: What is a reliable way of searching for any midi?
            int fd = open("/dev/midi1", O_RDONLY);
            if (fd > 0 ) {
                printf("Found MIDI device!\n");
                midi_reader_loop(fd, action, parser);
            }
            fd = open("/dev/midi2", O_RDONLY);
            if (fd > 0 ) {
                printf("Found MIDI device!\n");
                midi_reader_loop(fd, action, parser);
            }
            fd = open("/dev/midi3", O_RDONLY);
            if (fd > 0 ) {
                printf("Found MIDI device!\n");
                midi_reader_loop(fd, action, parser);
            }
            env->wait_for(env, SEC(1));
        }
    }
  =}

  state thread: pthread_t
  physical action a: midi_base_msg_t

  reaction(startup) -> a {=
    // Start the thread that is blocking on reading input
    pthread_create(&self->thread, NULL, &midi_reader_worker, a);
  =}

  reaction(a) -> midi_event {=
    lf_set(midi_event, a->value);
  =}

  reaction(shutdown) {=
    void* thread_exit_status;
    stop=true;
    pthread_join(self->thread, &thread_exit_status);
  =}
}

reactor CursesUserInterface extends UserInterface {
  keyboard = new KeyboardInput()
  state key_pressed_next: bool*
  state key_pressed: bool*
  state octave: int = {= NOTE_C4 =}
  state program: int = 0
  state filter_cutoff: int = 127;

  logical action killall
  logical action modulate: int
  logical action note_on: int

  reaction(startup) {=
    self->key_pressed = (bool *) malloc(NOTE_G9*sizeof(bool));
    self->key_pressed_next = (bool *) malloc(NOTE_G9*sizeof(bool));
    printf("Welcom to the psynth.\n");
    printf("Keyboard mapping:\n");
    printf(" w e   t y u\n");
    printf("a s d f g h j\n");
    printf("One keypress for NOTE_ON, another for NOTE_OFF\n");
    printf("Number=Move all tones UP number of half-tones\n");
    printf("Shift+Number=Move all tones DOWN number of half-tones\n");
    printf("c=change oscillator\n");
    printf("z/x= down/up an octave\n");
    printf("v=increase filter cut-off\n");
    printf("Shift+v=decrease filter cut-off\n");
    printf("q=turn off all notes\n");
  =}

  reaction(keyboard.key) -> midi_event, killall, modulate {=
    int note = -1;
    int program = -1;
    int filter = -1;

    switch(keyboard.key->value) {
        case 'a':
            note=self->octave+0;
            break;
        case 'w':
            note=self->octave+1;
            break;
        case 's':
            note=self->octave+2;
            break;
        case 'e':
            note=self->octave+3;
            break;
        case 'd':
            note=self->octave+4;
            break;
        case 'f':
            note=self->octave+5;
            break;
        case 't':
            note=self->octave+6;
            break;
        case 'g':
            note=self->octave+7;
            break;
        case 'y':
            note=self->octave+8;
            break;
        case 'h':
            note=self->octave+9;
            break;
        case 'u':
            note=self->octave+10;
            break;
        case 'j':
            note=self->octave+11;
            break;
        case 'k':
            note=self->octave+12;
            break;
        case 'z':
            self->octave-=12;
            break;
        case 'x':
            self->octave+=12;
            break;
        case 'c':
            program = (self->program+1) % NUM_OSC;
            break;
        case 'v':
            filter = (self->filter_cutoff+1);
            if (filter > 127) filter=127;
            break;
        case 'V':
            filter = (self->filter_cutoff-1);
            if (filter < 0) filter=0;
            break;
        case 'q':
            lf_schedule(killall, 0);
            break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
            lf_schedule(modulate, 0, keyboard.key->value - '0');
            break;
        case '!':
            lf_schedule(modulate, 0, -1);
            break;
        case '@':
            lf_schedule(modulate, 0, -2);
            break;
        case '#':
            lf_schedule(modulate, 0, -3);
            break;
        case '$':
            lf_schedule(modulate, 0, -4);
            break;
        case '%':
            lf_schedule(modulate, 0, -5);
            break;
        case '^':
            lf_schedule(modulate, 0, -6);
            break;
        case '&':
            lf_schedule(modulate, 0, -7);
            break;
        default:
            return;
            break;
    }

    if (note >= 0) {
        if (self->key_pressed[note]) {
            midi_note_on_t temp = MIDI_NOTE_OFF(note);
            self->key_pressed[note] = false;
            lf_set(midi_event, temp);
        } else {
            midi_note_on_t temp = MIDI_NOTE_ON(note);
            self->key_pressed[note] = true;
            lf_set(midi_event, temp);
        }
    } else if (program >= 0) {
        midi_controller_change_t temp = MIDI_OSC_CHANGE(program);
        self->program = program;
        lf_set(midi_event, temp);
    } else if (filter >= 0) {
        midi_controller_change_t temp = MIDI_FILTER_CUTOFF(filter);
        self->filter_cutoff = filter;
        lf_set(midi_event, temp);
    }
  =}

  reaction(killall) -> killall, midi_event {=
    for (int i=0; i<NOTE_G9; i++) {
        if (self->key_pressed[i]) {
            midi_note_on_t temp = MIDI_NOTE_OFF(i);
            self->key_pressed[i] = false;
            lf_set(midi_event, temp);
            lf_schedule(killall, 0);
            return;
        }
    }
  =}

  reaction(note_on) -> midi_event {=
    midi_note_on_t temp = MIDI_NOTE_ON(note_on->value);
    lf_set(midi_event, temp);
  =}

  reaction(modulate) -> note_on, midi_event, modulate {=
    for (int i=0; i<NOTE_G9; i++) {
        if (self->key_pressed[i]) {
            midi_note_on_t temp = MIDI_NOTE_OFF(i);
            self->key_pressed[i] = false;
            int modulated_tone = i + modulate->value;
            if (modulated_tone < 0) modulated_tone=0;
            if (modulated_tone > NOTE_G9) modulated_tone=NOTE_G9;

            self->key_pressed_next[modulated_tone] = true;
            lf_set(midi_event, temp);
            lf_schedule(note_on, 0, modulated_tone);
            lf_schedule(modulate, 1, modulate->value); // TODO: Why 1 nsec delay?
            return;
        }
    }
    for (int i=0; i<NOTE_G9; i++) {
        self->key_pressed[i] = self->key_pressed_next[i];
        self->key_pressed_next[i] = 0;
    }
  =}
}
