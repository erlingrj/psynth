target C;

import WebSocketServer from "lib/WebSocketServer.lf"
import KeyboardInput from "lib/Keyboard.lf"

preamble {= 
    #include <stdio.h>
    #include "common.h"
    #include "buffer.h"
    #include "midi.h"
    #include "platform.h"
=}

reactor UserInterface(sample_size:int=128) {
    input samples: sample_buffer_t*
    output midi_event:midi_base_msg_t;
}

reactor WebSocketUserInterface extends UserInterface {
    sock = new WebSocketServer(max_clients=1)
    state wsi: void* = 0 

    state buffer: SAMPLE_TYPE*
    state idx: int = 0;

    reaction(startup) {=
        self->buffer = (SAMPLE_TYPE *) malloc(SAMPLE_NUM_BYTES);
    =}
    
    reaction(sock.received) -> midi_event {=
        lf_print("Got MIDI from browser %s", sock.received->value->message);
    =}

    reaction(samples) -> sock.send {=
        if (self->wsi) {
            for (int i = 0; i<SAMPLE_SIZE; i=i+16) {
                self->buffer[self->idx++] = samples->value->samples[i];
            }
            if (self->idx == SAMPLE_SIZE) {
                char* message; web_socket_message_t* container = (web_socket_message_t*)malloc(sizeof(web_socket_message_t));
                container->message = (char *) self->buffer;
                container->length = SAMPLE_NUM_BYTES;
                container->wsi = self->wsi;
                lf_set(sock.send, container);
                self->idx = 0;
            }
        }
    =}





    reaction(sock.connected) {=
        if(sock.connected->value.connected) {
            lf_print("New client connected to our web socket");
            self->wsi = sock.connected->value.wsi;
        } else {
            lf_print("Client disconnected from our web socket");
            self->wsi = 0;
        }
    =}
}


reactor FileInterface extends UserInterface {
    preamble {=
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include "midi.h"

        int fd;

        void* midi_reader_worker(void *action) {
            midi_base_msg_t msg;
            char recv;
            while (1) {
                // Read a MIDI message (3 bytes)
                ssize_t bytes_read = read(fd, &recv, 1);

                // Check for errors or end-of-file
                if (bytes_read < 0) {
                    perror("Error reading MIDI data");
                    break;
                } else if (bytes_read == 0) {
                    printf("End of file reached\n");
                    break;
                }
                // printf("%02x \n", (unsigned char) recv);
                if (midi_parser(recv, &msg) == 0) {
                    // printf("FOUND MIDI MSG\n");
                    lf_schedule_copy(action, 0, &msg, sizeof(msg));
                    memset(&msg, 0, sizeof(msg));
                }
            }
        }
    =}

    state midi_fd: int;
    state thread: lf_thread_t
    physical action a: midi_base_msg_t

    reaction(startup) -> a {=
        // Open the MIDI device file
        self->midi_fd = open("/dev/midi1", O_RDONLY);
        if (self->midi_fd == -1) {
            lf_print_error_and_exit("Failed to open MIDI device");
            
        }
        fd = self->midi_fd;
        // Start the thread that is blocking on reading input
        lf_thread_create(&self->thread, &midi_reader_worker, a);
    =}

    reaction(a) -> midi_event {=
        memcpy(&midi_event->value, &a->value, sizeof(midi_base_msg_t));
        lf_set_present(midi_event);
    =}

    reaction(shutdown) {=
        // Close the MIDI device file
        close(self->midi_fd);
    =}
}

reactor CursesUserInterface extends UserInterface {
    keyboard = new KeyboardInput()
    state key_pressed_next:bool*
    state key_pressed:bool*;
    state octave:int = {=NOTE_C4=};
    state program:int = 0;
    reaction(startup) {=
        self->key_pressed = (bool *) malloc(NOTE_G9*sizeof(bool));
        self->key_pressed_next = (bool *) malloc(NOTE_G9*sizeof(bool));
    =}

    logical action killall;
    logical action modulate: int
    logical action note_on: int

    reaction(keyboard.key) -> midi_event, killall, modulate {=
        int note = -1;
        int program = -1;

        switch(keyboard.key->value) {
            case 'a':
                note=self->octave+0;
                break;
            case 'w':
                note=self->octave+1;
                break;
            case 's':
                note=self->octave+2;
                break;
            case 'e':
                note=self->octave+3;
                break;
            case 'd':
                note=self->octave+4;
                break;
            case 'f':
                note=self->octave+5;
                break;
            case 't':
                note=self->octave+6;
                break;
            case 'g':
                note=self->octave+7;
                break;
            case 'y':
                note=self->octave+8;
                break;
            case 'h':
                note=self->octave+9;
                break;
            case 'u':
                note=self->octave+10;
                break;
            case 'j':
                note=self->octave+11;
                break;
            case 'k':
                note=self->octave+12;
                break;
            case 'z':
                self->octave-=12;
                break;
            case 'x':
                self->octave+=12;
                break;
            case 'c':
                program = (self->program+1) % NUM_OSC;
                break;
            case 'q':
                lf_schedule(killall, 0);
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
                lf_schedule_int(modulate, 0, keyboard.key->value - '0');
                break;
            case '!':
                lf_schedule_int(modulate, 0, -1);
                break;
            case '@':
                lf_schedule_int(modulate, 0, -2);
                break;
            case '#':
                lf_schedule_int(modulate, 0, -3);
                break;
            case '$':
                lf_schedule_int(modulate, 0, -4);
                break;
            case '%':
                lf_schedule_int(modulate, 0, -5);
                break;
            case '^':
                lf_schedule_int(modulate, 0, -6);
                break;
            case '&':
                lf_schedule_int(modulate, 0, -7);
                break;
            default:
                lf_print("Illegal character");
                return;
                break;
        }

        if (note >= 0) {
            if (self->key_pressed[note]) {
                midi_note_on_t temp = MIDI_NOTE_OFF(note);
                memcpy(midi_event->value, &temp, sizeof(temp));
                self->key_pressed[note] = false;
            } else {
                midi_note_on_t temp = MIDI_NOTE_ON(note);
                memcpy(midi_event->value, &temp, sizeof(temp));
                self->key_pressed[note] = true;
            }
            lf_set_present(midi_event);
        } else if (program >= 0) {
            midi_program_change_t temp = MIDI_PROGRAM_CHANGE(program);
            memcpy(midi_event->value, &temp, sizeof(temp));
            self->program = program;
            lf_set_present(midi_event);
        } 
    =}
    reaction(killall) -> killall, midi_event {=
        for (int i=0; i<NOTE_G9; i++) {
            if (self->key_pressed[i]) {    
                midi_note_on_t temp = MIDI_NOTE_OFF(i);
                memcpy(midi_event->value, &temp, sizeof(temp));
                self->key_pressed[i] = false;
                lf_set_present(midi_event);
                lf_schedule(killall, 0);
                return;
            }
        }
    =}
    reaction(note_on) -> midi_event {=
        midi_note_on_t temp = MIDI_NOTE_ON(note_on->value);
        memcpy(midi_event->value, &temp, sizeof(temp));
        lf_set_present(midi_event);
    =}

    reaction(modulate) -> note_on, midi_event, modulate {=
        for (int i=0; i<NOTE_G9; i++) {
            if (self->key_pressed[i]) {    
                midi_note_on_t temp = MIDI_NOTE_OFF(i);
                memcpy(midi_event->value, &temp, sizeof(temp));
                self->key_pressed[i] = false;
                int modulated_tone = i + modulate->value;
                if (modulated_tone < 0) modulated_tone=0;
                if (modulated_tone > NOTE_G9) modulated_tone=NOTE_G9;

                self->key_pressed_next[modulated_tone] = true;
                lf_set_present(midi_event);
                lf_schedule_int(note_on, 0, modulated_tone);
                lf_schedule_int(modulate, 1, modulate->value);
                return;
            }
        }
        for (int i=0; i<NOTE_G9; i++) {
            self->key_pressed[i] = self->key_pressed_next[i];
            self->key_pressed_next[i] = 0;
        }
    =}
}
