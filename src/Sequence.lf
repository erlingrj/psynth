target C;

import KeyboardInput from "Keyboard.lf"

preamble {=
    #include "midi.h"
    #include <string.h> // memcpy
=}


reactor Sequence {
    output midi_event:int[3]
}

reactor RepeatedSequence(sequence: int[] = {48, 50, 52, 53, 49}, n_sequence: int = 5) extends Sequence {

    timer t_on(0, 1 sec)
    timer t_off(900 msec, 1 sec)

    state idx:int=0

    reaction(t_on) -> midi_event {=
        midi_note_on_t temp = MIDI_NOTE_ON(self->sequence[self->idx]);
        memcpy(midi_event->value, &temp, sizeof(temp));
        lf_set_present(midi_event);
    =}

    reaction(t_off) -> midi_event {=
        midi_note_off_t temp = MIDI_NOTE_OFF(self->sequence[self->idx]);
        memcpy(midi_event->value, &temp, sizeof(temp));
        
        if(++self->idx == self->n_sequence) {
            self->idx=0;
        }

        lf_set_present(midi_event);
    =}
}

reactor RandomSequence(period:time = 2 sec, length:int = 10) extends Sequence {
    timer t(0, period)
    timer tOff(900 msec, period)
    logical action off
    state note_playing:int

    preamble {=
    =}
    reaction(startup) {=
        srand(lf_time_physical());
    =}

    reaction(tOff) -> midi_event {=
        midi_note_off_t temp = MIDI_NOTE_OFF(self->note_playing);
        memcpy(midi_event->value, &temp, sizeof(temp));
        lf_set_present(midi_event);
    =}
    
    reaction(t) -> midi_event, off {=
        self->note_playing = 60 + rand() % 12;
        midi_note_on_t temp = MIDI_NOTE_ON(self->note_playing);
        memcpy(midi_event->value, &temp, sizeof(temp));
        lf_set_present(midi_event);
    =}

}

reactor KeyboardSequence extends Sequence {

    keyboard = new KeyboardInput()

    state key_pressed:bool*;

    reaction(startup) {=
        self->key_pressed = (bool *) malloc(127*sizeof(bool));
    =}

    reaction(keyboard.key) -> midi_event {=
        int note;

        switch(keyboard.key->value) {
            case 'a':
                note=NOTE_C3;
                break;
            case 'w':
                note=NOTE_CS3;
                break;
            case 's':
                note=NOTE_D3;
                break;
            case 'e':
                note=NOTE_DS3;
                break;
            case 'd':
                note=NOTE_E3;
                break;
            case 'f':
                note=NOTE_F3;
                break;
            case 't':
                note=NOTE_FS3;
                break;
            case 'g':
                note=NOTE_G3;
                break;
            case 'y':
                note=NOTE_GS3;
                break;
            case 'h':
                note=NOTE_A3;
                break;
            case 'u':
                note=NOTE_AS3;
                break;
            case 'j':
                note=NOTE_B3;
                break;
            case 'k':
                note=NOTE_C4;
                break;
            default:
                lf_print("Illegal character");
                return;
                break;
        }
        lf_print("Got %d", note);

        if (self->key_pressed[note]) {
            midi_note_on_t temp = MIDI_NOTE_OFF(note);
            memcpy(midi_event->value, &temp, sizeof(temp));
            self->key_pressed[note] = false;
        } else {
            midi_note_on_t temp = MIDI_NOTE_ON(note);
            memcpy(midi_event->value, &temp, sizeof(temp));
            self->key_pressed[note] = true;
        }
        lf_print("Got %d", note);
        lf_set_present(midi_event);
    =}
}