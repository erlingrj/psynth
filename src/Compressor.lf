/**
 * compressor.c - sound compression to prevent clipping
 *
 * Copyright (C) 2020 Christian Garbs <mitch@cgarbs.de> Copyright (C) 2023 Erling Jellum
 * <erling.jellum@gmail.com>
 *
 * Licensed under GNU GPL v3 (or later)
 *
 * This file is part of syndig, a simple software synthesizer written in C.
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program. If
 * not, see <http://www.gnu.org/licenses/>.
 */
target uC

preamble {=
  #include "psynth.h"
=}

// This compressor is copied from Christian Garbs syndig. I have also copied
// the original GPL licence. It is currently creating some glichy artifacts.
reactor Compressor {
  preamble {=
    #define NEUTRAL 1.0
    #define FALLOFF 0.01
  =}

  input in: sample_buffer_t
  output out: sample_buffer_t

  state compression: SAMPLE_TYPE = {= NEUTRAL =}
  state compressing: bool = false

  reaction(in) -> out {=
    sample_buffer_t samples;

    SAMPLE_TYPE min = 0;
    SAMPLE_TYPE max = 0;
    SAMPLE_TYPE compress = 0;

    for (int i = 0; i<SAMPLE_SIZE; i++) {
      SAMPLE_TYPE v = in->value.buffer[i];
      if (v < min) {
        min = v;
      }
      if (v > max) {
        max = v;
      }
    }
    max = MAX(max, -min);
    // lf_print("max=%f", max);
    if (max >= self->compression) {
      self->compression=max;
      self->compressing = true;
    } else {
      if (self->compression > NEUTRAL) {
        self->compression = MAX(self->compression - FALLOFF, NEUTRAL);
        if (self->compression == NEUTRAL) {
          self->compressing = false;
        }
      }
    }

    // Compress
    if (self->compressing) {
      printf("Compressing with %f\n", self->compression);
      for (int i = 0; i<SAMPLE_SIZE; i++) {
        samples.buffer[i] = in->value.buffer[i] / self->compression;
      }
      lf_set(out, samples);
    } else {
      lf_set(out, in->value);
    }
  =}
}
