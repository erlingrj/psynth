target uC

import FFT, IFFT from "FFT.lf"
import SimpleFilter from "Filter.lf"
import Compressor from "Compressor.lf"
import Merge, Lane from "Lane.lf"
import Delay from "Delay.lf"

preamble {=
  #include "psynth.h"
=}

reactor Synth(n_lanes:int = 3) {
  input midi_event: midi_base_msg_t
  output samples: sample_buffer_t
  output check_for_event: bool
  state lane_playing: int*

  lanes = new[3] Lane()
  merge = new Merge()
  delay = new Delay()
  fft = new FFT()
  ifft = new IFFT()
  filter = new SimpleFilter()
  compressor = new Compressor()

  lanes.samples -> merge.in
  merge.out -> fft.tsamples
  fft.fsamples -> filter.in
  filter.out -> ifft.fsamples
  ifft.tsamples -> compressor.in
  compressor.out -> samples

  logical action a

  reaction(startup) -> a {=
    self->lane_playing = (int *) malloc(self->n_lanes * sizeof(int));
    for (int i = 0; i<self->n_lanes; i++) {
        self->lane_playing[i] = LANE_IDLE;
    }

    lf_schedule(a, 0);
  =}

  reaction(a) -> lanes.do_sample, a, check_for_event {=
    for (int i = 0; i< lanes_width; i++) {
      lf_set(lanes[i].do_sample, true);
    }

    lf_schedule(a, SEC(SAMPLE_SIZE)/SAMPLE_RATE);
    lf_set(check_for_event, true);
  =}

  reaction(midi_event) -> lanes.note_on, lanes.note_off, lanes.ctrl, filter.ctrl {=
    midi_base_msg_t * midi_msg = &midi_event->value;

    print_midi(midi_msg);

    // Some MIDI keyboards dont send NOTE_OFF only NOTE_ON with velocity=0
    if (midi_msg->status.type == NOTE_ON &&
        ((midi_note_on_t *) midi_msg)->velocity==0) {
        midi_msg->status.type = NOTE_OFF;
    }

    switch (midi_msg->status.type) {
      case NOTE_OFF: {
        midi_note_off_t * note_off = (midi_note_off_t *) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          if (self->lane_playing[i] == note_off->pitch) {
            lf_set(lanes[i].note_off, *note_off);
            self->lane_playing[i] = LANE_RELEASING;
            // lf_print("OFF: Found note at lane %d", i);
            break;
          }
        }
        break;
      }
      case NOTE_ON: {
        midi_note_on_t * note_on = (midi_note_on_t *) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          if (self->lane_playing[i] == LANE_IDLE) {
            lf_set(lanes[i].note_on, *note_on);
            // lf_print("ON: Found note at lane %d", i);
            self->lane_playing[i] = note_on->pitch;
            break;
          }
        }
        break;
      }

      case CONTROL_CHANGE: {
        midi_controller_change_t * program = (midi_controller_change_t *) midi_msg;
        switch(program->controller) {
          case OSCILLATOR:
          case VOLUME:
          case OSCILLATOR_MOD:
          case AMP_ENVELOPE: {
            for (int i = 0; i<self->n_lanes; i++) {
              lf_set(lanes[i].ctrl, *program);
            }
            break;
          }

          case FILTER_ENVELOPE:
          case FILTER_FREQ:
          case MASTER_FILTER:
            lf_set(filter.ctrl, *program);
            break;
        }
      }
    }
  =}

  reaction(lanes.dead) {=
    for (int i = 0; i<self->n_lanes; i++) {
      if (lf_is_present(lanes[i].dead)) {
        // lf_print("DEAD lane %d", i);
        self->lane_playing[i] = LANE_IDLE;
      }
    }
  =}
}
