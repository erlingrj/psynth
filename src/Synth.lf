target C

import Oscillator from "Oscillator.lf"
import ADSREnvelope from "Envelope.lf"
import Compressor from "Compressor.lf"

preamble {=
  #include "midi.h"
  #include "freq.h"
  #include "common.h"
  #include "buffer.h"
  #include <string.h>
=}

reactor Synth(n_lanes: int = 4, sample_size:int=128) {
  input midi_event: midi_base_msg_t
  output samples: sample_buffer_t*
  state lane_playing: int*

  lanes = new[n_lanes] Lane()
  merge = new Merge(num_lanes=n_lanes)
  compressor = new Compressor()

  lanes.samples -> merge.in
  merge.out -> compressor.samples_raw
  compressor.samples -> samples
  

  reaction(startup) {=
    self->lane_playing = (int *) malloc(self->n_lanes * sizeof(int));
    for (int i = 0; i<self->n_lanes; i++) {
        self->lane_playing[i] = -1;
    }
  =}

  reaction(midi_event) -> lanes.note_on, lanes.note_off, lanes.freq, lanes.osc_type, lanes.velocity {=
    midi_base_msg_t * midi_msg = &midi_event->value;

    print_midi(midi_msg);

    // Some MIDI keyboards dont send NOTE_OFF only NOTE_ON with velocity=0
    if (midi_msg->status.type == NOTE_ON && 
        ((midi_note_on_t *) midi_msg)->velocity==0) {
        midi_msg->status.type = NOTE_OFF;
    }

    switch (midi_msg->status.type) {
      case NOTE_OFF: {
        midi_note_off_t * note_off = (midi_note_off_t *) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          if (self->lane_playing[i] == note_off->pitch) {
            lf_set(lanes[i].note_off, true);
            lf_print("OFF: Found note at lane %d", i);
            self->lane_playing[i] = -1;
            break;
          }
        }
        break;
      }
      case NOTE_ON: {
        midi_note_on_t * note_on = (midi_note_on_t *) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          if (self->lane_playing[i] == -1) {
            lf_set(lanes[i].note_on, true);
            lf_set(lanes[i].freq, freqs[note_on->pitch]);
            lf_set(lanes[i].velocity, note_on->velocity);
            lf_print("ON: Found note at lane %d", i);
            self->lane_playing[i] = note_on->pitch;
            break;
          }
        }
        break;
      }

      case CONTROL_CHANGE: {
        midi_program_change_t * program = (midi_program_change_t*) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          lf_set(lanes[i].osc_type, program->program);
        }
        break;
      }
    }
  =}
}

reactor Lane(bank_index: int = 0, sample_size:int=128) {
  input note_on: bool
  input note_off: bool
  input freq: double
  input velocity: double
  input osc_type: osc_type_t
  output samples: sample_buffer_t*

  osc = new Oscillator(initialType = {= OSC_SINE =})
  env = new ADSREnvelope()

  note_on -> env.note_on
  note_off -> env.note_off
  velocity -> env.velocity
  freq -> osc.freq
  osc_type -> osc.type

  osc.samples -> env.samples_raw
  env.samples -> samples
  env.dead -> osc.dead
}

reactor Merge(num_lanes:int=1) {
  input [num_lanes] in:sample_buffer_t*
  output out:sample_buffer_t*

  reaction(startup) -> out {=
    lf_set_destructor(out, sample_buffer_destructor);
    lf_set_copy_constructor(out, sample_buffer_copy);
  =}

  reaction(in) -> out {=
    sample_buffer_t * buffer = sample_buffer_ctor();
    for (int i=0; i<in_width; i++) {
      if (in[i]->is_present) {
        for (int j=0; j<SAMPLE_SIZE; j++) {
          buffer->samples[j] += in[i]->value->samples[j];
        }
      }
    }
    lf_set(out, buffer);
  =}
}