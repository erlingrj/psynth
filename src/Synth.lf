target C

import Oscillator from "Oscillator.lf"
import ADSREnvelope from "Envelope.lf"

preamble {=
  #include "midi.h"
  #include "freq.h"
  #include "common.h"
  #include <string.h>
=}

reactor Synth(n_lanes: int = 4, sample_size:int=128) {
  input[2] midi_event: int[3]
  output samples: sample_buf_t
  state lane_playing: int*

  lanes = new[n_lanes] Lane()

  reaction(startup) {=
    self->lane_playing = (int *) malloc(self->n_lanes * sizeof(int));
    for (int i = 0; i<self->n_lanes; i++) {
        self->lane_playing[i] = -1;
    }
  =}

  reaction(midi_event) -> lanes.note_on, lanes.note_off, lanes.freq, lanes.osc_type {=
    midi_base_msg_t * midi_msg;
    if (midi_event[0]->is_present) {
      midi_msg = (midi_base_msg_t *) midi_event[0]->value;
    } else {
      midi_msg = (midi_base_msg_t *) midi_event[1]->value;
    }
    switch (midi_msg->status.type) {
      case NOTE_OFF: {
        midi_note_off_t * note_off = (midi_note_off_t *) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          if (self->lane_playing[i] == note_off->pitch) {
            lf_print("OFF: %i", note_off->pitch);
            lf_set(lanes[i].note_off, true);
            self->lane_playing[i] = -1;
            break;
          }
        }
        break;
      }
      case NOTE_ON: {
        lf_print("ON");
        midi_note_on_t * note_on = (midi_note_on_t *) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          if (self->lane_playing[i] == -1) {
            lf_print("ON: %i", note_on->pitch);
            lf_set(lanes[i].note_on, true);
            lf_set(lanes[i].freq, freqs[note_on->pitch]);
            self->lane_playing[i] = note_on->pitch;
            break;
          }
        }
        break;
      }

      case PROGRAM_CHANGE: {
        midi_program_change_t * program = (midi_program_change_t*) midi_msg;
        for (int i = 0; i<self->n_lanes; i++) {
          lf_set(lanes[i].osc_type, program->program);
        }
        break;
      }
    }
  =}

  reaction(lanes.samples) -> samples {=
    int n_present = 0;
    for (int i=0; i<lanes_width; i++) {
      if (lanes[i].samples->is_present) {
        n_present++;
      }
    }
    for (int i=0; i<SAMPLE_SIZE; i++) {
      float v = 0;
      for (int j=0; j<lanes_width; j++) {
        if (lanes[j].samples->is_present) {
          v += lanes[j].samples->value[i]/n_present;
        }
      }
      samples->value[i] = v;
    }
    lf_set_present(samples);
  =}
}

reactor Lane(bank_index: int = 0, sample_size:int=128) {
  input note_on: bool
  input note_off: bool
  input freq: double
  input osc_type: osc_type_t
  output samples: sample_buf_t

  osc = new Oscillator(initialType = {= OSC_SINE =})
  env = new ADSREnvelope()

  note_on -> env.note_on
  note_off -> env.note_off
  freq -> osc.freq
  osc_type -> osc.type

  osc.samples -> env.samples_raw
  env.samples -> samples
}
