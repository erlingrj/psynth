/**
 * Output the key code for any key pressed on the keyboard. The timestamp of the output is the
 * physical time at which the key is pressed.
 *
 * This reactor uses curses, a reasonably portable C library for terminal interactions. If your
 * program sends messages to the standard output, then you should print the messages using
 * `lf_print` rather than `printf` so that they are cleanly displayed on the terminal.
 *
 * If a non-zero exit_key parameter is given, then it is the key code for a key that, when pressed,
 * will cause this reactor to call lf_request_stop(), bringing the program to exit.
 *
 * @see ../rhythm/SensorSimulator.lf
 * @author Edward A. Lee
 */
target uC {
  keepalive: true,
  cmake-include: ["curses.cmake"]
}

preamble {=
  #ifndef KEYBOARD_PREAMBLE
  #define KEYBOARD_PREAMBLE
    #include <pthread.h>

    typedef struct keyboard_input_t {
      pthread_mutex_t mutex; 
      bool new_pressed;
      char key_pressed; // Which key was pressed
      int exit_key;   // Keycode for exiting.
    } keyboard_input_t;

  #endif
=}

reactor KeyboardInput(exit_key: int = 0) {
  output key: int
  input check_for_event: bool

  preamble {=
    #include <pthread.h>
    #include <curses.h>
    #include <signal.h>
    
    // Thread to read input characters until an EOF is received.
    // Each time a character is received, schedule a keypress action.
    void* read_input(void* _keyboard_input) {
      keyboard_input_t* keyboard_input = (keyboard_input_t*)_keyboard_input;
      int c;
      while((c = getch()) != EOF) {
        if (c == keyboard_input->exit_key) {
          exit(1);
          break;
        }
        pthread_mutex_lock(&keyboard_input->mutex);
        keyboard_input->new_pressed = true;
        keyboard_input->key_pressed = c;
        pthread_mutex_unlock(&keyboard_input->mutex);
      }
      return NULL;
    }
    // Function to direct printed messages to the curses-managed terminal.
    void print_to_terminal(const char* format, va_list args) {
      static int line_count = 1;
      move(line_count++, 0);
      vwprintw(stdscr, format, args);
      refresh();
      if(line_count >= getmaxy(stdscr)) line_count = 1;
    }
    // Function for orderly shutdown upon control-c.
    void sig_handler(int sig) {
      exit(1);
    }
  =}

  state keyboard_input: keyboard_input_t

  reaction(startup) {=
    initscr();  // Initialize the curses library
    cbreak();   // Disable line buffering
    noecho();   // Disable automatic echoing of typed characters
    keypad(stdscr, TRUE);  // Enable special keys

    move(0, 0);
    if(self->exit_key != 0) {
      printw("Type %c to exit.\n", self->exit_key);
    }
    refresh();

    if (signal(SIGINT, sig_handler) == SIG_ERR) {
      validate(false);
    }

    self->keyboard_input.exit_key = self->exit_key;
    pthread_mutex_init(&self->keyboard_input.mutex, NULL);

    // Start the thread that listens for key presses.
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, read_input, &self->keyboard_input);
  =}

  reaction(check_for_event) -> key {=
    if (self->keyboard_input.new_pressed) {
      pthread_mutex_lock(&self->keyboard_input.mutex);
      lf_set(key, self->keyboard_input.key_pressed);
      self->keyboard_input.new_pressed = false;
      pthread_mutex_unlock(&self->keyboard_input.mutex);
    }
  =}

  reaction(shutdown) {=
    endwin();
    // lf_register_print_function(NULL, -1);
  =}
}

main reactor {
  k = new KeyboardInput(exit_key=120)

  reaction(k.key) {=
    printf("You typed %c (keycode %d)\n", k.key->value, k.key->value);
  =}
}
