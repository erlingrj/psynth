target uC

import Oscillator from "./Oscillator.lf"
import ADSREnvelope from "./Envelope.lf"

preamble {=
  #include "psynth.h"
=}

reactor Lane(bank_index: int = 0) {
  input note_on: midi_note_on_t
  input note_off: midi_note_off_t
  input do_sample: bool
  input ctrl: midi_controller_change_t
  output samples: sample_buffer_t
  output dead: bool

  osc = new Oscillator(initialType = {= OSC_SINE =})
  do_sample -> osc.do_sample
  envelope = new ADSREnvelope()
  osc.samples -> envelope.samples_raw
  envelope.samples -> samples
  envelope.dead -> osc.dead
  envelope.dead -> dead

  reaction(note_on) -> envelope.note_on, envelope.velocity_in, osc.freq_in {=
    lf_set(envelope.note_on, true);
    lf_set(envelope.velocity_in, note_on->value.velocity);
    lf_set(osc.freq_in, freqs[note_on->value.pitch]);
  =}

  reaction(note_off) -> envelope.note_off {=
    lf_set(envelope.note_off, true);
  =}

  reaction(ctrl) -> osc.type_in, osc.amp, envelope.ctrl {=
    switch(ctrl->value.controller) {
          case OSCILLATOR: {
            osc_type_t osc_type = ctrl->value.value >> 5;
            if(osc_type > 3) {
              validate(false);
            }
            lf_set(osc.type_in, osc_type);
            break;
          }
          case VOLUME: {
            double amp = ((double )ctrl->value.value) / 127;
            lf_set(osc.amp, amp);
          }
            break;
          case OSCILLATOR_MOD:
            break;
          case AMP_ENVELOPE:
            lf_set(envelope.ctrl, ctrl->value);
            break;
    }
  =}
}

reactor Merge {
  input[3] in: sample_buffer_t
  output out: sample_buffer_t

  reaction(in) -> out {=
    sample_buffer_t samples;
    memset(&samples, 0, sizeof(sample_buffer_t));
    int n_present = 0;
    for (int i = 0; i<in_width; i++) {
      if (lf_is_present(in[i])) {
        n_present++;
      }
    }
    // lf_print("n_present=%d", n_present);

    for (int i=0; i<in_width; i++) {
      if (lf_is_present(in[i])) {
        for (int j=0; j<SAMPLE_SIZE; j++) {
          samples.buffer[j] += in[i]->value.buffer[j]/in_width;
        }
      }
    }
    lf_set(out, samples);
  =}
}
